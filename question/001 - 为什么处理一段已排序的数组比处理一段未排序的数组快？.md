<https://stackoverflow.com/questions/11227809/why-is-it-faster-to-process-a-sorted-array-than-an-unsorted-array>

## 问题

下面是一段很神奇的 C++ 代码，因为某种未知的原因，排序后的数组执行速率快了近 6 倍。

```c++
#include <algorithm>
#include <ctime>
#include <iostream>

int main()
{
    // Generate data
    const unsigned arraySize = 32768;
    int data[arraySize];

    for (unsigned c = 0; c < arraySize; ++c)
        data[c] = std::rand() % 256;

    // !!! With this, the next loop runs faster
    std::sort(data, data + arraySize);

    // Test
    clock_t start = clock();
    long long sum = 0;

    for (unsigned i = 0; i < 100000; ++i)
    {
        // Primary loop
        for (unsigned c = 0; c < arraySize; ++c)
        {
            if (data[c] >= 128)
                sum += data[c];
        }
    }

    double elapsedTime = static_cast<double>(clock() - start) / CLOCKS_PER_SEC;

    std::cout << elapsedTime << std::endl;
    std::cout << "sum = " << sum << std::endl;
}
```

- 如果不加`std::sort(data, data + arraySize)`这句代码的话，所耗时间为 11.54 秒。
- 如果加上去，只耗了 1.93 秒。

起初，我认为可能是语言或者编译器搞的鬼，所以我用 Java 试了下。

```java
import java.util.Arrays;
import java.util.Random;

public class Main
{
    public static void main(String[] args)
    {
        // Generate data
        int arraySize = 32768;
        int data[] = new int[arraySize];

        Random rnd = new Random(0);
        for (int c = 0; c < arraySize; ++c)
            data[c] = rnd.nextInt() % 256;

        // !!! With this, the next loop runs faster
        Arrays.sort(data);

        // Test
        long start = System.nanoTime();
        long sum = 0;

        for (int i = 0; i < 100000; ++i)
        {
            // Primary loop
            for (int c = 0; c < arraySize; ++c)
            {
                if (data[c] >= 128)
                    sum += data[c];
            }
        }

        System.out.println((System.nanoTime() - start) / 1000000000.0);
        System.out.println("sum = " + sum);
    }
}
```

最后的结果也是类似。

我起初的想法是，排序导致了缓存，所以后续的执行会更快，但后来想了想，不对，因为数组已经生成在那里了，缓存也在。所以，

- 这到底是怎么回事呢？
- 为什么处理一段已排序的数组比处理一段未排序的数组快？
- 代码只是做些加法这些运算，顺序应该不会造成影响啊。

## 最佳回答

你误解了分支预测器（Branch predictor）。

什么是分支预测器（Branch predictor）？想象一个铁路枢纽，如下图，

![](https://github.com/Hapoa/stackoverflow-top-cpp/blob/master/image/001.jpg)

假设现在你回到了上世纪的 80 年代，并且是一个铁路枢纽的控制人员。当你听见火车来了，你不知道它应该往哪条轨道上走，于是你让火车停下，问下了司机，得到答案后再切换到正确的轨道上。

但是你要知道，火车很大很重，让它停下再启动相当麻烦。

有更好的方法么？猜一下这辆火车应该去哪条轨道！

- 如果你猜对了，恭喜你。
- 如果你猜错了，火车还需要停下、倒退回来、再启动开往正确的轨道上，甚至可能会影响别的火车。

**如果你每次都猜对了**，火车自然不会停下。
**如果你经常猜错**，火车就会花费很多时间在停下、倒退和重启上面。

现在请考虑一个 if 语句，从处理器的角度来看，它就是一个分支预测器（Branch predictor）。

![](https://github.com/Hapoa/stackoverflow-top-cpp/blob/master/image/002.png)

假设现在你就是那个处理器，你看到了这样的语句，但是你不知道它接下来该运行到哪步。你该怎么做？


