<https://stackoverflow.com/questions/11227809/why-is-it-faster-to-process-a-sorted-array-than-an-unsorted-array>

## 问题

下面是一段很神奇的 C++ 代码，因为某种未知的原因，排序后的数组执行速率快了近 6 倍。

```c++
#include <algorithm>
#include <ctime>
#include <iostream>

int main()
{
    // Generate data
    const unsigned arraySize = 32768;
    int data[arraySize];

    for (unsigned c = 0; c < arraySize; ++c)
        data[c] = std::rand() % 256;

    // !!! With this, the next loop runs faster
    std::sort(data, data + arraySize);

    // Test
    clock_t start = clock();
    long long sum = 0;

    for (unsigned i = 0; i < 100000; ++i)
    {
        // Primary loop
        for (unsigned c = 0; c < arraySize; ++c)
        {
            if (data[c] >= 128)
                sum += data[c];
        }
    }

    double elapsedTime = static_cast<double>(clock() - start) / CLOCKS_PER_SEC;

    std::cout << elapsedTime << std::endl;
    std::cout << "sum = " << sum << std::endl;
}
```

- 如果不加`std::sort(data, data + arraySize)`这句代码的话，所耗时间为 11.54 秒。
- 如果加上去，只耗了 1.93 秒。

起初，我认为可能是语言或者编译器搞的鬼，所以我用 Java 试了下。

```java
import java.util.Arrays;
import java.util.Random;

public class Main
{
    public static void main(String[] args)
    {
        // Generate data
        int arraySize = 32768;
        int data[] = new int[arraySize];

        Random rnd = new Random(0);
        for (int c = 0; c < arraySize; ++c)
            data[c] = rnd.nextInt() % 256;

        // !!! With this, the next loop runs faster
        Arrays.sort(data);

        // Test
        long start = System.nanoTime();
        long sum = 0;

        for (int i = 0; i < 100000; ++i)
        {
            // Primary loop
            for (int c = 0; c < arraySize; ++c)
            {
                if (data[c] >= 128)
                    sum += data[c];
            }
        }

        System.out.println((System.nanoTime() - start) / 1000000000.0);
        System.out.println("sum = " + sum);
    }
}
```

最后的结果也是类似。

我起初的想法是，排序导致了缓存，所以后续的执行会更快，但后来想了想，不对，因为数组已经生成在那里了，缓存也在。所以，

- 这到底是怎么回事呢？
- 为什么处理一段已排序的数组比处理一段未排序的数组快？
- 代码只是做些加法这些运算，顺序应该不会造成影响啊。

## 最佳回答

你误解了分支预测（Branch Prediction）的这个概念。

什么是分支预测（Branch Prediction）？想象一个铁路枢纽，如下图，

![](https://github.com/Hapoa/stackoverflow-top-cpp/blob/master/image/001.jpg)

假设现在你回到了上世纪的 80 年代，并且是一个铁路枢纽的控制人员。当你听见火车来了，你不知道它应该往哪条轨道上走，于是你让火车停下，问了下司机，得到答案后再切换到正确的轨道上。

但是你要知道，火车很大很重，让它停下再启动相当麻烦。

那么有更好的方法么？你可以猜一下这辆火车应该去哪条轨道啊！

- 如果你猜对了，恭喜你。
- 如果你猜错了，火车还需要停下、倒退回来、再启动开往正确的轨道上，甚至可能会影响别的火车。

**如果你每次都猜对了**，火车自然不会停下。
**如果你经常猜错**，火车就会花费很多时间在停下、倒退和重启上面。

现在请考虑一个 if 语句，从处理器的角度来看，它就是一个分支预测（Branch Prediction）。

![](https://github.com/Hapoa/stackoverflow-top-cpp/blob/master/image/002.png)

假设现在你就是那个处理器，你看到了这样的语句，但是你不知道它接下来该运行到哪步。你该怎么做？暂停执行直到上一条语句执行完毕，然后继续。（现代处理器因为有更长的指令流水线，所以启动和停止将耗时更久）

有更好的方法么？可以猜一下下一条要执行的指令！

- 如果你猜对了，恭喜你。
- 如果你猜错了，你就需要刷新指令流水线、回退，然后重新执行。

**如果你每次都猜对了**，执行自然不会停下。
**如果你经常猜错**，你就需要花费很多时间在暂停、回退和重新执行上面。

这就是分支预测（Branch Prediction）。我承认用火车来类比确实不太好，因为火车在来的时候完全可以用旗子打个信号它要开往哪个轨道上。但是要知道，计算机处理器是不知道下一条指令是什么的，它只能等到上一条指令完毕才会获知。

所以，你该以什么样的策略来猜测火车要跑的轨道，且能最大程度上降低出错的概率呢？可以观察下这辆火车以往的历史路线，如果在这个时刻，这辆火车 99% 都开往了左侧的这条轨道，那你就猜左；如果都是右侧轨道，那你就猜右；如果......

**也就是说，你可以遵循一种模式。**这差不多也是分支预测（Branch Prediction）的工作原理。

大多数的应用应用程序都带有分支预测（Branch Prediction）。现代的[分支预测器](https://zh.wikipedia.org/wiki/%E5%88%86%E6%94%AF%E9%A0%90%E6%B8%AC%E5%99%A8)基本上都能达到 90% 以上的命中率。但是在面对一些复杂的难以预测的情况下，分支预测器就会显得有些鸡肋。

上面说了这么多，其实你问的这个问题的**罪魁祸首就是下面的这个 if 语句**：

```c++
if (data[c] >= 128)
    sum += data[c];
```

数据的范围只在 0-255 之间。当数据被排序后，前半部分肯定是不会进入 if 语句中的，后半部分才都会进入 if 语句。

这就方便分支预测器了。除了中间那次切换，其他的都可以按照指定的方向进行运算。

```
T = branch taken
N = branch not taken

data[] = 0, 1, 2, 3, 4, ... 126, 127, 128, 129, 130, ... 250, 251, 252, ...
branch = N  N  N  N  N  ...   N    N    T    T    T  ...   T    T    T  ...

       = NNNNNNNNNNNN ... NNNNNNNTTTTTTTTT ... TTTTTTTTTT  (easy to predict)
```

如果数据是无序的，分支预测器就无用了，因为它不能预测无序的数据。

```
data[] = 226, 185, 125, 158, 198, 144, 217, 79, 202, 118,  14, 150, 177, 182, 133, ...
branch =   T,   T,   N,   T,   T,   T,   T,  N,   T,   N,   N,   T,   T,   T,   N  ...

       = TTNTTTTNTNNTTTN ...   (completely random - hard to predict)
```
       
如果你不想要编译器使用分支预测，你可以这么做：

替换：

```c++
if (data[c] >= 128)
    sum += data[c];
```

为：

```
int t = (data[c] - 128) >> 31;
sum += ~t & data[c];
```

就此题而言，两个语句做的事情其实是等同的，只是用位运算来替换 if 语句而已。

测试环境：Core i7 920 @ 3.5 GHz

C++ - Visual Studio 2010 - x64 Release

```
//  Branch - Random
seconds = 11.777

//  Branch - Sorted
seconds = 2.352

//  Branchless - Random
seconds = 2.564

//  Branchless - Sorted
seconds = 2.587
```

Java - NetBeans 7.1.1 JDK 7 - x64

```
//  Branch - Random
seconds = 10.93293813

//  Branch - Sorted
seconds = 5.643797077

//  Branchless - Random
seconds = 3.113581453

//  Branchless - Sorted
seconds = 3.186068823
```

结论：

- 带有分支预测的，已排序的和无序的执行时间有很大差异。
- 不带分支分支预测的，没有差异。
