<https://stackoverflow.com/questions/106508/what-is-a-smart-pointer-and-when-should-i-use-one>

## 问题

什么是智能指针？什么时候用它们？

## 回答

从较浅的层面看，智能指针是利用了一种叫做 RAII（资源获取即初始化）的技术对普通的指针进行封装，这使得智能指针实质是一个对象，行为表现的却像一个指针。作用当然很明显，防止忘记调用 delete，当然还有另一个作用，就是异常安全。在一段进行了 try/catch 的代码段里面，即使你写入了 delete，也有可能因为发生异常，程序进入 catch 块，从而忘记释放内存，这些都可以通过智能指针解决。

但是智能指针还有一重更加深刻的含义，就是把 value 语义转化为 reference 语义。C++ 和 Java 有一处最大的区别在于语义不同。

在 Java 里面下列代码：

```java
Animal a = new Animal();
Animal b = a;
```

你当然知道，这里其实只生成了一个对象，a 和 b 仅仅是把持对象的引用而已。但在 C++ 中不是这样，

```c++
Animal a;
Animal b;
```

这里确实就是生成了两个对象。

在编写 OOP 程序时，value 语义带来太多的困扰。例如 TCP 连接中我封装一个 accept 函数接收请求，那么应该是这样的：

```c++
Socket accept();
```

这就带来一个问题，采用对象做返回值，这里面有一个对象的复制的过程，但是 Socket 因为某些原因，我让他继承了 boost::noncopyable，总之就是 Socket 失去了复制和赋值的能力，那么该怎么办？我们首先想到指针，在 accept 内部 new 生成一个对象，然后返回指针。但是问题更多，这个对象何时析构？ 过早析构，程序发生错误，不进行析构，又造成了内存泄露。

这里的解决方案就是智能指针，而且是引用计数型的智能指针。

```c++
typedef boost::shared<Socket> SocketPtr;
SocketPtr accept();
```

这样外部就可以用智能指针去接收，那么何时析构？当然是引用计数为 0，也就是我不再需要这个 Socket 的时候析构。这样，我们利用了 SockerPtr，实现了跟 Java 类似的 Reference 语义。

还有一个例子，Java 中往容器中放对象，实际放入的是引用，不是真正的对象，而 C++ 在 vector 中 push_back 采用的是值拷贝，如果想实现 Java 中的引用语义，就应该使用智能指针，可以参考《C++ 标准库程序》（侯捷/孟岩 译）的第五章讲容器的部分，有一节叫做“用 Value 语义实现 Reference 语义”，还有陈硕的那本《Linux 多线程服务器端编程》11.7 节。

C++ 标准一共有四种智能指针：auto_ptr、unique_ptr、shared_ptr 和 weak_ptr。其中 auto_ptr 在 C++ 11 已被摒弃，C++ 17 中被移除不可用了。

### auto_ptr

**所有的**智能指针类的构造函数都以 explicit 修饰，因此不能隐式将指针转换为智能指针对象，必须显式调用：

```c++
auto_ptr<double> pd;
double *p_reg = new double;

pd = p_reg;  // not allowed (implicit conversion)
pd = shared_ptr<double>(p_reg); // allowed (explicit conversion)

auto_ptr<double> autoP = p_reg; // not allowed (implicit conversion)
auto_ptr<double> autoP(p_reg); // allowed (explicit conversion)
```

auto_ptr 可以实现对象的 RAII，那为什么要摒弃呢？先来看下面的赋值语句:

```c++
auto_ptr< string> ps (new string("I reigned lonely as a cloud.”));
auto_ptr<string> vocation;
vocaticn = ps;
```

上述赋值语句将完成什么工作呢？如果 ps 和 vocation 是常规指针，则两个指针将指向同一个 string 对象。这是不能接受的，因为程序将试图删除同一个对象两次：一次是 ps 过期时，另一次是 vocation 过期时。

要避免这种问题，方法有多种：

1. 定义陚值运算符，使之执行深复制。这样两个指针将指向不同的对象，其中的一个对象是另一个对象的副本，缺点是浪费空间，所以智能指针都未采用此方案。
2. 建立所有权（ownership）概念。对于特定的对象，只能有一个智能指针可拥有，这样只有拥有对象的智能指针的构造函数会删除该对象。然后让赋值操作转让所有权。这就是用于 auto_ptr 和 unique_ptr 的策略，但 unique_ptr 的策略更严格。
3. 创建智能更高的指针，跟踪引用特定对象的智能指针数，这称为引用计数。例如，赋值时，计数将加 1，而指针过期时，计数将减 1,。当减为 0 时才调用 delete。这是 shared_ptr 采用的策略。

你会发现，使用 auto_ptr 所隐藏的的弊处可能远比它带来的利要多，这就是为何要摒弃 auto_ptr 的原因。也因此 C++ 11 发布了新式的三种智能指针用以取代和扩展更丰富的功能。

### unique_ptr



## 参考

- <https://www.zhihu.com/question/20368881/answer/331873847>
- <https://www.zhihu.com/question/20368881/answer/25835250>
