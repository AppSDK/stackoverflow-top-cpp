<https://stackoverflow.com/questions/106508/what-is-a-smart-pointer-and-when-should-i-use-one>

## 问题

什么是智能指针？什么时候用它们？

## 回答

从较浅的层面看，智能指针是利用了一种叫做 RAII（资源获取即初始化）的技术对普通的指针进行封装，这使得智能指针实质是一个对象，行为表现的却像一个指针。作用当然很明显，防止忘记调用 delete，当然还有另一个作用，就是异常安全。在一段进行了 try/catch 的代码段里面，即使你写入了 delete，也有可能因为发生异常，程序进入 catch 块，从而忘记释放内存，这些都可以通过智能指针解决。

但是智能指针还有一重更加深刻的含义，就是把 value 语义转化为 reference 语义。C++ 和 Java 有一处最大的区别在于语义不同。

在 Java 里面下列代码：

```java
Animal a = new Animal();
Animal b = a;
```

你当然知道，这里其实只生成了一个对象，a 和 b 仅仅是把持对象的引用而已。但在 C++ 中不是这样，

```c++
Animal a;
Animal b;
```

这里确实就是生成了两个对象。

在编写 OOP 程序时，value 语义带来太多的困扰。例如 TCP 连接中我封装一个 accept 函数接收请求，那么应该是这样的：

```c++
Socket accept();
```

这就带来一个问题，采用对象做返回值，这里面有一个对象的复制的过程，但是 Socket 因为某些原因，我让他继承了 boost::noncopyable，总之就是 Socket 失去了复制和赋值的能力，那么该怎么办？我们首先想到指针，在 accept 内部 new 生成一个对象，然后返回指针。但是问题更多，这个对象何时析构？ 过早析构，程序发生错误，不进行析构，又造成了内存泄露。

这里的解决方案就是智能指针，而且是引用计数型的智能指针。

```c++
typedef boost::shared<Socket> SocketPtr;
SocketPtr accept();
```

这样外部就可以用智能指针去接收，那么何时析构？当然是引用计数为 0，也就是我不再需要这个 Socket 的时候析构。这样，我们利用了 SockerPtr，实现了跟 Java 类似的 Reference 语义。

还有一个例子，Java 中往容器中放对象，实际放入的是引用，不是真正的对象，而 C++ 在 vector 中 push_back 采用的是值拷贝，如果想实现 Java 中的引用语义，就应该使用智能指针，可以参考《C++ 标准库程序》（侯捷/孟岩 译）的第五章讲容器的部分，有一节叫做“用 Value 语义实现 Reference 语义”，还有陈硕的那本《Linux 多线程服务器端编程》11.7 节。




## 参考

- <https://www.zhihu.com/question/20368881/answer/25835250>
