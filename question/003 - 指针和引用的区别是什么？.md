<https://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in>

## 问题

我知道引用是语法糖，用起来方便。但是它们之间到底有啥区别呢？

>译注：上面是整个问题，下面是题主根据回答总结出的内容，并不是提问内容。

根据下面的回答总结如下，并附重要链接：

 1. 指针可以被无限制进行赋值操作，但是引用一旦被绑定一个变量上，就不可以再让它绑定到另外一个变量。
 2. 指针可以指向任何地方，包括`nullptr`，但是引用必须绑定在一个实实在在的变量实体上去。
 3. 指针变量有自己的所占的空间和地址，引用变量没有。
 4. 指针有算术运算（Pointer Arithmetic），比如`p++`，但是引用是没有所谓的算术运算的。

>译注：Pointer Arithmetic 的含义参见参考链接 1。

有必要说下我们常见的一个误解。

C++ 标准并没有明确要求编译器该如何实现引用，但是基本上所有编译器在底层处理上都会把引用当做指针来处理。比如下面是一个引用，

```c++
int &ri = i;
```

**如果未被编译器完全优化**，那么它的底层实现其实就和指针一样，开辟一段内存，存放 i 的地址。

**所以，指针和引用其实都消耗同样的内存大小。**

一般来说，

- 引用用于函数的参数和返回值，有的时候会很有用。比如参数`const std::string& name`，还有单例模式中的引用返回。
- 指针常用于实现算法和数据结构。

另外附一些可能需要的链接：

- [My all-time favorite C++ FAQ lite](http://yosefk.com/c++fqa/ref.html)
- [References vs. Pointers](http://www.embedded.com/electronics-blogs/programming-pointers/4023307/References-vs-Pointers)
- [An Introduction to References](http://www.embedded.com/electronics-blogs/programming-pointers/4024641/An-Introduction-to-References)
- [References and const](http://www.embedded.com/electronics-blogs/programming-pointers/4023290/References-and-const)

## 最佳回答

 1. 指针可以被赋值，
 ```c++
 int x = 5;
int y = 6;
int *p;
p =  &x;
p = &y;
*p = 10;
assert(x == 5);
assert(y == 10);
 ```
 引用不可以，且必须初始化。
 ```c++
 int x = 5;
int y = 6;
int &r = x;
 ```
 2. 指针变量有自己的实际地址和所占空间的大小，x86 上一般是 32 位，但是引用是和它绑定的变量共享一个地址（其实编译器实在底层处理上都会把引用当做指针来处理，也就是说它其实也是占空间的）。因为引用和绑定的变量共享一块内存，所以你可以简单的认为，引用就是这个变量的另一个别名。注意：指针指向的既可以是栈也可以是堆，在这点上，引用也是一样的。
 ```c++
 int x = 0;
int &r = x;
int *p = &x;
int *p2 = &r;
assert(p == p2);
 ```
 3. 指针可以指向指针的指针，指针的指针的指针，甚至更多层的指针，但引用只能有一层。
 ```c++
 int x = 0;
int y = 0;
int *p = &x;
int *q = &y;
int **pp = &p;
pp = &q;//*pp = q
**pp = 4;
assert(y == 4);
assert(x == 0);
 ```
 4. 指针可以赋为 nullptr，但引用不能初始化为空。当然你也可以使用其他的方法（毕竟奇淫技巧多）来实现。
 ```c++
 int *p = nullptr;
int &r = nullptr; <--- compiling error
int &r = *p;  <--- likely no compiling error, especially if the nullptr is hidden behind a function call, yet it refers to a non-existent int at address 0
 ```
 5. 指针支持算术运算（Pointer Arithmetic），比如一个指针数组，使用`++`就可以拿到下一个位置的指针，`+4`就可以拿到后面的第四个。
 6. 指针需要以`*`来取值，引用不用。指向结构体或类对象的指针，还可以以`->`来获取其内部的成员，引用则使用`.`。
 7. 指针本质上是一个变量，它有自己所占用的空间和地址，（暂不谈底层处理）引用则是与其绑定的变量共享空间和地址。
 8. 没有“引用数组”这种说法，只有“指针数组”。
 9. 常量引用很有用，它可以绑定临时对象，也就是右值，指针不行，搞不好会段错误。
 ```c++
 const int &x = int(12); //legal C++
int *y = &int(12); //illegal to dereference a temporary.
 ```
 所以啊，经常可以看到形参类型是常量引用`const type&`的。

## 参考链接

- [https://en.wikipedia.org/wiki/Pointer_(computer_programming)#C_and_C++](https://en.wikipedia.org/wiki/Pointer_(computer_programming)#C_and_C++)
